#ifndef _REACT_NATIVE_CHAIN_LIBS_
#define _REACT_NATIVE_CHAIN_LIBS_

/* Generated with cbindgen:0.9.1 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum {
  Production = 0,
  Test = 1,
} AddressDiscrimination;

typedef enum {
  Single = 0,
  Group = 1,
  Account = 2,
  Multisig = 3,
} AddressKind;

typedef enum {
  StakeDelegation = 0,
  OwnerStakeDelegation = 1,
  PoolRegistration = 2,
  PoolRetirement = 3,
  PoolUpdate = 4,
} CertificateKind;

typedef struct {
  void *_0;
} RPtr;

typedef const char *CharPtr;

typedef struct {
  const uint8_t *ptr;
  uintptr_t len;
} DataPtr;

bool account_binding_signature_new_single(RPtr private_key,
                                          RPtr auth_data,
                                          RPtr *result,
                                          CharPtr *error);

bool account_from_address(RPtr address, RPtr *result, CharPtr *error);

bool account_single_from_public_key(RPtr key, RPtr *result, CharPtr *error);

bool address_account_from_public_key(RPtr key,
                                     AddressDiscrimination discrimination,
                                     RPtr *result,
                                     CharPtr *error);

bool address_as_bytes(RPtr address, DataPtr *result, CharPtr *error);

bool address_delegation_from_public_key(RPtr key,
                                        RPtr delegation,
                                        AddressDiscrimination discrimination,
                                        RPtr *result,
                                        CharPtr *error);

bool address_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool address_from_string(CharPtr string, RPtr *result, CharPtr *error);

bool address_get_discrimination(RPtr address, AddressDiscrimination *result, CharPtr *error);

bool address_get_kind(RPtr address, AddressKind *result, CharPtr *error);

bool address_single_from_public_key(RPtr key,
                                    AddressDiscrimination discrimination,
                                    RPtr *result,
                                    CharPtr *error);

bool address_to_account_address(RPtr address, RPtr *result, CharPtr *error);

bool address_to_group_address(RPtr address, RPtr *result, CharPtr *error);

bool address_to_single_address(RPtr address, RPtr *result, CharPtr *error);

bool address_to_string(RPtr ptr, CharPtr prefix, CharPtr *result, CharPtr *error);

bool balance_get_value(RPtr balance, RPtr *result, CharPtr *error);

bool balance_is_negative(RPtr balance, bool *result, CharPtr *error);

bool balance_is_positive(RPtr balance, bool *result, CharPtr *error);

bool balance_is_zero(RPtr balance, bool *result, CharPtr *error);

bool bip32_public_key_as_bytes(RPtr bip32_public_key, DataPtr *result, CharPtr *error);

bool bip32_public_key_derive(RPtr bip32_public_key, int64_t index, RPtr *result, CharPtr *error);

bool bip32_public_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool bip32_public_key_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool bip32_public_key_to_bech32(RPtr bip32_public_key, CharPtr *result, CharPtr *error);

bool bip32_public_key_to_raw_key(RPtr bip32_public_key, RPtr *result, CharPtr *error);

bool bip_32_private_key_as_bytes(RPtr bip_32_private_key, DataPtr *result, CharPtr *error);

bool bip_32_private_key_derive(RPtr bip_32_private_key,
                               int64_t index,
                               RPtr *result,
                               CharPtr *error);

bool bip_32_private_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool bip_32_private_key_from_bip39_entropy(const uint8_t *entropy_data,
                                           uintptr_t entropy_len,
                                           const uint8_t *password_data,
                                           uintptr_t password_len,
                                           RPtr *result,
                                           CharPtr *error);

bool bip_32_private_key_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool bip_32_private_key_generate_ed25519_bip32(RPtr *result, CharPtr *error);

bool bip_32_private_key_to_bech32(RPtr bip_32_private_key, CharPtr *result, CharPtr *error);

bool bip_32_private_key_to_public(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool bip_32_private_key_to_raw_key(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool certificate_get_owner_stake_delegation(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_get_pool_registration(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_get_pool_retirement(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_get_stake_delegation(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_get_type(RPtr certificate, CertificateKind *result, CharPtr *error);

bool certificate_stake_delegation(RPtr stake_delegation, RPtr *result, CharPtr *error);

bool certificate_stake_pool_registration(RPtr pool_registration, RPtr *result, CharPtr *error);

bool certificate_stake_pool_retirement(RPtr pool_retirement, RPtr *result, CharPtr *error);

void charptr_free(CharPtr *ptr);

void dataptr_free(DataPtr *data);

bool delegation_type_full(RPtr pool_id, RPtr *result, CharPtr *error);

bool delegation_type_get_full(RPtr delegation_type, RPtr *result, CharPtr *error);

bool delegation_type_get_kind(RPtr delegation_type, RPtr *result, CharPtr *error);

bool delegation_type_non_delegated(RPtr *result, CharPtr *error);

bool delegation_type_ratio(RPtr r, RPtr *result, CharPtr *error);

bool fee_calculate(RPtr fee, RPtr tx, RPtr *result, CharPtr *error);

bool fee_linear_fee(RPtr constant,
                    RPtr coefficient,
                    RPtr certificate,
                    RPtr per_certificate_fee,
                    RPtr *result,
                    CharPtr *error);

bool fragment_as_bytes(RPtr fragment, DataPtr *result, CharPtr *error);

bool fragment_from_transaction(RPtr tx, RPtr *result, CharPtr *error);

bool fragment_get_transaction(RPtr fragment, RPtr *result, CharPtr *error);

bool fragment_id(RPtr fragment, RPtr *result, CharPtr *error);

bool fragment_id_as_bytes(RPtr fragment_id, DataPtr *result, CharPtr *error);

bool fragment_id_calculate(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool fragment_id_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool fragment_is_initial(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_old_utxo_declaration(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_owner_stake_delegation(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_pool_registration(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_pool_retirement(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_pool_update(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_stake_delegation(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_transaction(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_update_proposal(RPtr fragment, bool *result, CharPtr *error);

bool fragment_is_update_vote(RPtr fragment, bool *result, CharPtr *error);

bool group_address_get_account_key(RPtr group_address, RPtr *result, CharPtr *error);

bool hash_from_hex(CharPtr hex_string, RPtr *result, CharPtr *error);

void init_chain_libs_library(void);

bool input_from_account(RPtr account, RPtr v, RPtr *result, CharPtr *error);

bool input_from_utxo(RPtr utxo_pointer, RPtr *result, CharPtr *error);

bool input_output_builder_add_input(RPtr io_builder, RPtr input, CharPtr *error);

bool input_output_builder_add_output(RPtr io_builder, RPtr address, RPtr value, CharPtr *error);

bool input_output_builder_build(RPtr *io_builder, RPtr *result, CharPtr *error);

bool input_output_builder_empty(RPtr *result, CharPtr *error);

bool input_output_builder_estimate_fee(RPtr io_builder,
                                       RPtr fee,
                                       RPtr payload,
                                       RPtr *result,
                                       CharPtr *error);

bool input_output_builder_get_balance(RPtr io_builder,
                                      RPtr payload,
                                      RPtr fee,
                                      RPtr *result,
                                      CharPtr *error);

bool input_output_builder_seal_with_output_policy(RPtr *io_builder,
                                                  RPtr payload,
                                                  RPtr fee_algorithm,
                                                  RPtr policy,
                                                  RPtr *result,
                                                  CharPtr *error);

bool input_output_inputs(RPtr input_output, RPtr *result, CharPtr *error);

bool input_output_outputs(RPtr input_output, RPtr *result, CharPtr *error);

bool input_value(RPtr input, RPtr *result, CharPtr *error);

bool inputs_add(RPtr inputs, RPtr *item, CharPtr *error);

bool inputs_get(RPtr inputs, uintptr_t index, RPtr *result, CharPtr *error);

bool inputs_new(RPtr *result, CharPtr *error);

bool inputs_size(RPtr inputs, uintptr_t *result, CharPtr *error);

bool output_address(RPtr output, RPtr *result, CharPtr *error);

bool output_policy_forget(RPtr *result, CharPtr *error);

bool output_policy_one(RPtr address, RPtr *result, CharPtr *error);

bool output_value(RPtr output, RPtr *result, CharPtr *error);

bool outputs_add(RPtr outputs, RPtr *item, CharPtr *error);

bool outputs_get(RPtr outputs, uintptr_t index, RPtr *result, CharPtr *error);

bool outputs_new(RPtr *result, CharPtr *error);

bool outputs_size(RPtr outputs, uintptr_t *result, CharPtr *error);

bool payload_auth_data_for_no_payload(RPtr *result, CharPtr *error);

bool payload_auth_data_for_stake_delegation(RPtr stake_delegation_auth_data,
                                            RPtr *result,
                                            CharPtr *error);

bool payload_certificate(RPtr certificate, RPtr *result, CharPtr *error);

bool payload_no_payload(RPtr *result, CharPtr *error);

bool per_certificate_fee_new(RPtr *result, CharPtr *error);

bool per_certificate_fee_set_owner_stake_delegation(RPtr per_certificate_fee,
                                                    RPtr val,
                                                    CharPtr *error);

bool per_certificate_fee_set_pool_registration(RPtr per_certificate_fee, RPtr val, CharPtr *error);

bool per_certificate_fee_set_stake_delegation(RPtr per_certificate_fee, RPtr val, CharPtr *error);

bool pool_id_from_hex(CharPtr hex_string, RPtr *result, CharPtr *error);

bool private_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool private_key_from_extended_bytes(const uint8_t *data,
                                     uintptr_t len,
                                     RPtr *result,
                                     CharPtr *error);

bool private_key_to_public(RPtr private_key, RPtr *result, CharPtr *error);

bool public_key_as_bytes(RPtr pub_key, DataPtr *result, CharPtr *error);

bool public_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

void rptr_free(RPtr *ptr);

RPtr rptr_from_usize(uintptr_t usz);

uintptr_t rptr_into_usize(RPtr ptr);

bool spending_counter_from_u32(uint32_t counter, RPtr *result, CharPtr *error);

bool spending_counter_zero(RPtr *result, CharPtr *error);

bool stake_delegation_account(RPtr stake_delegation, RPtr *result, CharPtr *error);

bool stake_delegation_as_bytes(RPtr stake_delegation, DataPtr *result, CharPtr *error);

bool stake_delegation_auth_data_new(RPtr signature, RPtr *result, CharPtr *error);

bool stake_delegation_delegation_type(RPtr stake_delegation, RPtr *result, CharPtr *error);

bool stake_delegation_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool stake_delegation_new(RPtr delegation_type, RPtr account, RPtr *result, CharPtr *error);

bool transaction_builder_new(RPtr *result, CharPtr *error);

bool transaction_builder_no_payload(RPtr *tx_builder, RPtr *result, CharPtr *error);

bool transaction_builder_payload(RPtr *tx_builder, RPtr cert, RPtr *result, CharPtr *error);

bool transaction_builder_set_auth_data_get_auth_data(RPtr tx_builder_set_auth_data,
                                                     RPtr *result,
                                                     CharPtr *error);

bool transaction_builder_set_auth_data_set_payload_auth(RPtr *tx_builder_set_auth_data,
                                                        RPtr auth,
                                                        RPtr *result,
                                                        CharPtr *error);

bool transaction_builder_set_ios_set_ios(RPtr *tx_builder_set_ios,
                                         RPtr inputs,
                                         RPtr outputs,
                                         RPtr *result,
                                         CharPtr *error);

bool transaction_builder_set_witness_get_auth_data_for_witness(RPtr tx_builder_set_witness,
                                                               RPtr *result,
                                                               CharPtr *error);

bool transaction_builder_set_witness_set_witnesses(RPtr *tx_builder_set_witness,
                                                   RPtr witnesses,
                                                   RPtr *result,
                                                   CharPtr *error);

bool transaction_id(RPtr transaction, RPtr *result, CharPtr *error);

bool transaction_inputs(RPtr transaction, RPtr *result, CharPtr *error);

bool transaction_outputs(RPtr transaction, RPtr *result, CharPtr *error);

bool transaction_sign_data_hash_as_bytes(RPtr tx_sign_data_hash, DataPtr *result, CharPtr *error);

bool transaction_sign_data_hash_from_bytes(const uint8_t *data,
                                           uintptr_t len,
                                           RPtr *result,
                                           CharPtr *error);

bool transaction_sign_data_hash_from_hex(CharPtr input, RPtr *result, CharPtr *error);

bool utxo_pointer_new(RPtr fragment_id,
                      uint8_t output_index,
                      RPtr value,
                      RPtr *result,
                      CharPtr *error);

bool value_checked_add(RPtr value, RPtr other, RPtr *result, CharPtr *error);

bool value_checked_sub(RPtr value, RPtr other, RPtr *result, CharPtr *error);

bool value_from_str(CharPtr chars, RPtr *result, CharPtr *error);

bool value_from_u64(uint64_t u, RPtr *result, CharPtr *error);

bool value_to_str(RPtr value, CharPtr *result, CharPtr *error);

bool witness_for_account(RPtr genesis_hash,
                         RPtr transaction_id,
                         RPtr secret_key,
                         RPtr account_spending_counter,
                         RPtr *result,
                         CharPtr *error);

bool witness_for_legacy_icarus_utxo(RPtr genesis_hash,
                                    RPtr transaction_id,
                                    RPtr secret_key,
                                    RPtr *result,
                                    CharPtr *error);

bool witness_for_utxo(RPtr genesis_hash,
                      RPtr transaction_id,
                      RPtr secret_key,
                      RPtr *result,
                      CharPtr *error);

bool witnesses_add(RPtr witnesses, RPtr *item, CharPtr *error);

bool witnesses_get(RPtr witnesses, uintptr_t index, RPtr *result, CharPtr *error);

bool witnesses_new(RPtr *result, CharPtr *error);

bool witnesses_size(RPtr witnesses, uintptr_t *result, CharPtr *error);

#endif /* _REACT_NATIVE_CHAIN_LIBS_ */
